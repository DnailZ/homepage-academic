<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yuantian Ding</title><link>https://dnailz.github.io/homepage-academic/</link><atom:link href="https://dnailz.github.io/homepage-academic/index.xml" rel="self" type="application/rss+xml"/><description>Yuantian Ding</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 27 Apr 2016 00:00:00 +0000</lastBuildDate><image><url>https://dnailz.github.io/homepage-academic/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url><title>Yuantian Ding</title><link>https://dnailz.github.io/homepage-academic/</link></image><item><title>Leverage JIT Code and Profile Sharing for serverless application</title><link>https://dnailz.github.io/homepage-academic/project/jit/</link><pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate><guid>https://dnailz.github.io/homepage-academic/project/jit/</guid><description>&lt;p>The serverless computing model leverages high-level languages, such as JavaScript and Java, to raise the level of abstraction for cloud programming. However, today’s design of serverless computing platforms based on stateless short-lived functions leads to missed opportunities for modern runtimes to optimize serverless functions through techniques such as JIT compilation and code profiling.&lt;/p>
&lt;p>We found that modern serverless platforms can not fully leverage language runtime optimizations: Modern serverless platforms can not share JIT-compiled code between different instances. From the picture, we noticed original serverless function can be accelerated by JIT code and profile sharing.&lt;/p>
&lt;p>Working in progress: I&amp;rsquo;m trying to implement this on HotspotVM. &lt;a href="https://dnailz.github.io/homepage-academic/homepage-academic/uploads/JITRelocation.pdf">Implementation Report&lt;/a>&lt;/p></description></item><item><title>Order Scheduling in Disk-based Graph Processing</title><link>https://dnailz.github.io/homepage-academic/project/graph/</link><pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate><guid>https://dnailz.github.io/homepage-academic/project/graph/</guid><description>&lt;p>Graph processing is a common task that has been researched for many years. You can model many real-world structures in graphs: social networks, web documents … In most of the time, graphs are stored as sparse matrices. But in many real-world problems, sparse matrices are sometimes too large to fit into memory. We may use distributed strategy to resolve this problem. However, recent research has shown that the single machine disk-based method outperforms many distributed ones in many cases. But these disk-based graph processing systems still have a lot of IO overhead. To address this problem, we proposed a new graph task ordering algorithm that can reduce almost 50% of data loading from the disk.&lt;/p>
&lt;p>The process of this algorithm is shown in this &lt;a href="https://dnailz.github.io/homepage-academic/homepage-academic/uploads/Ordering.pdf">slides&lt;/a>.&lt;/p></description></item><item><title/><link>https://dnailz.github.io/homepage-academic/admin/config.yml</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dnailz.github.io/homepage-academic/admin/config.yml</guid><description/></item></channel></rss>